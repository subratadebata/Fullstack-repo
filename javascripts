what is closures?

In JavaScript, a closure is a function that can access variables from its outer function, even after the outer function has finished executing. Closures are created when a function is defined inside another function. 
Lexical scope ?

Lexical scope in JavaScript is a programming concept that determines the scope of a variable based on where it's declared in the code. It's also known as static scoping. 

Event Loop and Asynchronous JavaScript
JavaScript uses an event loop to handle asynchronous operations. The call stack, callback queue, and microtask queue work together to execute synchronous and asynchronous code.

Execution Process:
Synchronous code executes first (Call Stack).
Promises and async/await go into the Microtask Queue (higher priority than Callback Queue).
Callbacks from events, timers, or async operations go into the Callback Queue.
Hoisting
Hoisting is JavaScript‚Äôs behavior of moving variable and function declarations to the top of their scope before execution.
Scope and Lexical Scope
Scope determines where a variable can be accessed.
Lexical Scope refers to how nested functions inherit variables from their parent functions.
this Keyword
The this keyword refers to the object that is executing the function.

Rules for this:
Global Scope (Non-strict Mode): this refers to window in browsers.
Inside an Object Method: this refers to the object.
Arrow Functions: this is lexically bound (does not get its own this).
Inside a Constructor Function: this refers to the new instance.
Callbacks, Promises, and Async/Await
Callbacks: Functions passed as arguments to be executed later.
Promises: Objects that represent future values (Pending, Fulfilled, Rejected).
Async/Await: Modern syntax for handling Promises.
 Destructuring
A way to extract values from arrays or objects.
Debouncing and Throttling
Debouncing: Delays execution until after a pause.
Throttling: Limits execution at fixed intervals.
What is the Virtual DOM in React?
The Virtual DOM (VDOM) is a lightweight, in-memory representation of the real DOM used by React to optimize UI rendering and updates efficiently.

How the Virtual DOM Works?
React creates a Virtual DOM tree that mirrors the actual DOM.
When state changes, React creates a new Virtual DOM.
React compares the new Virtual DOM with the previous one using a process called Reconciliation.
React determines the minimal changes (diffing algorithm) and updates only the necessary parts in the real DOM.
The Real DOM is updated efficiently, improving performance.
1. Types of Garbage Collectors in Java
Java provides multiple garbage collectors, each optimized for different performance requirements.

Garbage Collector	Algorithm Type	Best For
Serial GC	Stop-the-world, Mark-Sweep-Compact	Single-threaded environments
Parallel GC (Throughput GC)	Multi-threaded, Mark-Sweep-Compact	High throughput, multi-core systems
CMS (Concurrent Mark-Sweep) GC	Concurrent, Mark-Sweep	Low-latency applications
G1 (Garbage First) GC	Region-based, Concurrent	Balanced performance for large heaps
ZGC	Region-based, Low-latency	Very low pause times for large heaps
Shenandoah GC	Region-based, Concurrent	Extremely low pause times, multi-threaded
2. Java Memory Structure for GC
Java Heap Memory is divided into different regions:

Young Generation (Eden + Survivor Spaces)
Newly created objects.
Minor GC collects short-lived objects.
Old Generation (Tenured)
Long-lived objects that survive multiple GCs.
Major GC (Full GC) occurs here.
Metaspace
Stores class metadata (replaces PermGen in Java 8+).
3. Garbage Collection Algorithms
1Ô∏è‚É£ Serial Garbage Collector
Uses a single thread for GC.
Stop-the-world event pauses all application threads.
Suitable for small Java applications with a single-core CPU.
JVM Option: -XX:+UseSerialGC
üîπ Algorithm:

Mark ‚Äì Identifies live objects.
Sweep ‚Äì Removes dead objects.
Compact ‚Äì Defragments memory to reduce fragmentation.
2Ô∏è‚É£ Parallel Garbage Collector (Throughput GC)
Uses multiple threads for GC.
Still causes stop-the-world pauses.
Suitable for applications with high CPU power and large heaps.
JVM Option: -XX:+UseParallelGC
üîπ Algorithm:

Parallel Minor GC for Young Generation.
Parallel Major GC (Full GC) for Old Generation.
3Ô∏è‚É£ CMS (Concurrent Mark-Sweep) Garbage Collector (Deprecated in Java 14)
Reduces pause times by running concurrent threads for GC.
Best for low-latency applications.
JVM Option: -XX:+UseConcMarkSweepGC
üîπ Algorithm Steps:

Initial Mark ‚Äì Stops the application briefly to mark live objects.
Concurrent Mark ‚Äì Runs concurrently with application.
Concurrent Sweep ‚Äì Frees unused objects.
Final Remark ‚Äì Stops application briefly to finalize GC.
‚ùó Downsides:

Can cause fragmentation.
More CPU-intensive.
4Ô∏è‚É£ G1 (Garbage First) Garbage Collector (Default in Java 9+)
Region-based collector (instead of generational model).
Prioritizes regions with the most garbage.
JVM Option: -XX:+UseG1GC
üîπ Algorithm Steps:

Initial Mark ‚Äì Quick scan of heap.
Concurrent Marking ‚Äì Runs in the background.
Evacuation Pause ‚Äì Moves objects to compact memory.
Cleanup ‚Äì Removes unused regions.
‚úÖ Advantages:

Balanced performance.
Low pause times.
5Ô∏è‚É£ ZGC (Low-Latency GC)
Ultra-low pause times (<10ms), even with large heaps (up to 16TB).
JVM Option: -XX:+UseZGC
üîπ Key Features:

Fully concurrent ‚Äì GC runs alongside application.
Does not stop application threads.
6Ô∏è‚É£ Shenandoah GC
Similar to ZGC, with even shorter pause times.
JVM Option: -XX:+UseShenandoahGC
üîπ Key Features:

Concurrent Compaction ‚Äì Avoids full GC pauses.
Suitable for high-throughput, low-latency applications.
4. Choosing the Right Garbage Collector
Application Type	Best GC Choice
Small applications, single-threaded	Serial GC
Large-scale, CPU-intensive	Parallel GC
Low-latency apps	CMS (deprecated) / G1 GC
Ultra-low latency, large heap	ZGC / Shenandoah
5. How to Set GC in JVM
You can specify the garbage collector in your JVM options:

bash
Copy
Edit
java -XX:+UseG1GC -jar MyApp.jar  # Use G1 GC
java -XX:+UseParallelGC -jar MyApp.jar  # Use Parallel GC
java -XX:+UseZGC -jar MyApp.jar  # Use ZGC
Conclusion
Garbage Collection improves memory management in Java.
Different GC algorithms cater to different application needs.
G1 GC is the default in Java 9+, but ZGC and Shenandoah offer better performance for low-latency applications.
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           JVM Memory         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ    Method Area (Metaspace)   ‚îÇ  <-- Class Metadata, Static Variables
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ           Heap               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ  Young   ‚îÇ    Old       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ(Eden, S0, S1) | Tenured ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ      Stack (Each Thread)     ‚îÇ  <-- Method Call Stack, Local Variables
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Native Method Stack (JNI)   ‚îÇ  <-- Calls Native C/C++ Methods
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ      Program Counter (PC)    ‚îÇ  <-- Current Execution Line
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
