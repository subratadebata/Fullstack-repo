what is closures?

In JavaScript, a closure is a function that can access variables from its outer function, even after the outer function has finished executing. Closures are created when a function is defined inside another function. 
Lexical scope ?

Lexical scope in JavaScript is a programming concept that determines the scope of a variable based on where it's declared in the code. It's also known as static scoping. 

Event Loop and Asynchronous JavaScript
JavaScript uses an event loop to handle asynchronous operations. The call stack, callback queue, and microtask queue work together to execute synchronous and asynchronous code.

Execution Process:
Synchronous code executes first (Call Stack).
Promises and async/await go into the Microtask Queue (higher priority than Callback Queue).
Callbacks from events, timers, or async operations go into the Callback Queue.
Hoisting
Hoisting is JavaScript‚Äôs behavior of moving variable and function declarations to the top of their scope before execution.
Scope and Lexical Scope
Scope determines where a variable can be accessed.
Lexical Scope refers to how nested functions inherit variables from their parent functions.
this Keyword
The this keyword refers to the object that is executing the function.

Rules for this:
Global Scope (Non-strict Mode): this refers to window in browsers.
Inside an Object Method: this refers to the object.
Arrow Functions: this is lexically bound (does not get its own this).
Inside a Constructor Function: this refers to the new instance.
Callbacks, Promises, and Async/Await
Callbacks: Functions passed as arguments to be executed later.
Promises: Objects that represent future values (Pending, Fulfilled, Rejected).
Async/Await: Modern syntax for handling Promises.
 Destructuring
A way to extract values from arrays or objects.
Debouncing and Throttling
Debouncing: Delays execution until after a pause.
Throttling: Limits execution at fixed intervals.
What is the Virtual DOM in React?
The Virtual DOM (VDOM) is a lightweight, in-memory representation of the real DOM used by React to optimize UI rendering and updates efficiently.

How the Virtual DOM Works?
React creates a Virtual DOM tree that mirrors the actual DOM.
When state changes, React creates a new Virtual DOM.
React compares the new Virtual DOM with the previous one using a process called Reconciliation.
React determines the minimal changes (diffing algorithm) and updates only the necessary parts in the real DOM.
The Real DOM is updated efficiently, improving performance.
1. Types of Garbage Collectors in Java
Java provides multiple garbage collectors, each optimized for different performance requirements.

Garbage Collector	Algorithm Type	Best For
Serial GC	Stop-the-world, Mark-Sweep-Compact	Single-threaded environments
Parallel GC (Throughput GC)	Multi-threaded, Mark-Sweep-Compact	High throughput, multi-core systems
CMS (Concurrent Mark-Sweep) GC	Concurrent, Mark-Sweep	Low-latency applications
G1 (Garbage First) GC	Region-based, Concurrent	Balanced performance for large heaps
ZGC	Region-based, Low-latency	Very low pause times for large heaps
Shenandoah GC	Region-based, Concurrent	Extremely low pause times, multi-threaded
2. Java Memory Structure for GC
Java Heap Memory is divided into different regions:

Young Generation (Eden + Survivor Spaces)
Newly created objects.
Minor GC collects short-lived objects.
Old Generation (Tenured)
Long-lived objects that survive multiple GCs.
Major GC (Full GC) occurs here.
Metaspace
Stores class metadata (replaces PermGen in Java 8+).
3. Garbage Collection Algorithms
1Ô∏è‚É£ Serial Garbage Collector
Uses a single thread for GC.
Stop-the-world event pauses all application threads.
Suitable for small Java applications with a single-core CPU.
JVM Option: -XX:+UseSerialGC
üîπ Algorithm:

Mark ‚Äì Identifies live objects.
Sweep ‚Äì Removes dead objects.
Compact ‚Äì Defragments memory to reduce fragmentation.
2Ô∏è‚É£ Parallel Garbage Collector (Throughput GC)
Uses multiple threads for GC.
Still causes stop-the-world pauses.
Suitable for applications with high CPU power and large heaps.
JVM Option: -XX:+UseParallelGC
üîπ Algorithm:

Parallel Minor GC for Young Generation.
Parallel Major GC (Full GC) for Old Generation.
3Ô∏è‚É£ CMS (Concurrent Mark-Sweep) Garbage Collector (Deprecated in Java 14)
Reduces pause times by running concurrent threads for GC.
Best for low-latency applications.
JVM Option: -XX:+UseConcMarkSweepGC
üîπ Algorithm Steps:

Initial Mark ‚Äì Stops the application briefly to mark live objects.
Concurrent Mark ‚Äì Runs concurrently with application.
Concurrent Sweep ‚Äì Frees unused objects.
Final Remark ‚Äì Stops application briefly to finalize GC.
‚ùó Downsides:

Can cause fragmentation.
More CPU-intensive.
4Ô∏è‚É£ G1 (Garbage First) Garbage Collector (Default in Java 9+)
Region-based collector (instead of generational model).
Prioritizes regions with the most garbage.
JVM Option: -XX:+UseG1GC
üîπ Algorithm Steps:

Initial Mark ‚Äì Quick scan of heap.
Concurrent Marking ‚Äì Runs in the background.
Evacuation Pause ‚Äì Moves objects to compact memory.
Cleanup ‚Äì Removes unused regions.
‚úÖ Advantages:

Balanced performance.
Low pause times.
5Ô∏è‚É£ ZGC (Low-Latency GC)
Ultra-low pause times (<10ms), even with large heaps (up to 16TB).
JVM Option: -XX:+UseZGC
üîπ Key Features:

Fully concurrent ‚Äì GC runs alongside application.
Does not stop application threads.
6Ô∏è‚É£ Shenandoah GC
Similar to ZGC, with even shorter pause times.
JVM Option: -XX:+UseShenandoahGC
üîπ Key Features:

Concurrent Compaction ‚Äì Avoids full GC pauses.
Suitable for high-throughput, low-latency applications.
4. Choosing the Right Garbage Collector
Application Type	Best GC Choice
Small applications, single-threaded	Serial GC
Large-scale, CPU-intensive	Parallel GC
Low-latency apps	CMS (deprecated) / G1 GC
Ultra-low latency, large heap	ZGC / Shenandoah
5. How to Set GC in JVM
You can specify the garbage collector in your JVM options:

bash
Copy
Edit
java -XX:+UseG1GC -jar MyApp.jar  # Use G1 GC
java -XX:+UseParallelGC -jar MyApp.jar  # Use Parallel GC
java -XX:+UseZGC -jar MyApp.jar  # Use ZGC
Conclusion
Garbage Collection improves memory management in Java.
Different GC algorithms cater to different application needs.
G1 GC is the default in Java 9+, but ZGC and Shenandoah offer better performance for low-latency applications.
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           JVM Memory         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ    Method Area (Metaspace)   ‚îÇ  <-- Class Metadata, Static Variables
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ           Heap               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ  Young   ‚îÇ    Old       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ(Eden, S0, S1) | Tenured ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ      Stack (Each Thread)     ‚îÇ  <-- Method Call Stack, Local Variables
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Native Method Stack (JNI)   ‚îÇ  <-- Calls Native C/C++ Methods
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ      Program Counter (PC)    ‚îÇ  <-- Current Execution Line
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

1. Types of Garbage Collectors in Java
Java provides multiple garbage collection algorithms, each with trade-offs in throughput, latency, and pause times.

Garbage Collector	Best For	GC Type	JVM Option
Serial GC	Small apps, single-threaded environments	Stop-the-world, single-threaded	-XX:+UseSerialGC
Parallel GC (Throughput GC)	High throughput, multi-threaded apps	Stop-the-world, multi-threaded	-XX:+UseParallelGC
G1 GC (Garbage First)	Low-latency, balanced apps	Region-based, concurrent	-XX:+UseG1GC
ZGC (Z Garbage Collector)	Ultra-low-latency, large heaps	Region-based, concurrent	-XX:+UseZGC
Shenandoah GC	Low-pause, real-time systems	Region-based, concurrent	-XX:+UseShenandoahGC
2. How Different Java GC Algorithms Work
üîπ Serial GC (Best for Small Applications)
Uses a single thread for garbage collection.
Performs stop-the-world (STW) pauses.
Suitable for small heap sizes (<1GB).
üîπ Enable Serial GC

bash
Copy
Edit
java -XX:+UseSerialGC -jar app.jar
üîπ How It Works

Stops all application threads during GC.
Runs Minor GC (Young Gen) and Major GC (Old Gen) sequentially.
Causes long pause times, so not suitable for large applications.
üîπ Parallel GC (Best for High Throughput)
Uses multiple threads to perform GC.
Focuses on throughput (faster execution, longer pauses).
Still performs stop-the-world but faster than Serial GC.
üîπ Enable Parallel GC

bash
Copy
Edit
java -XX:+UseParallelGC -jar app.jar
üîπ How It Works

Uses multiple threads to clean Young Gen.
Uses multiple threads for Full GC but still pauses the application.
Best for batch processing systems where pauses don‚Äôt matter.
üîπ G1 Garbage Collector (Best for Balanced Performance)
Divides heap into regions (Eden, Survivor, Old) instead of fixed generations.
Performs concurrent garbage collection, reducing pause times.
Prioritizes collecting regions with most garbage first.
üîπ Enable G1 GC

bash
Copy
Edit
java -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -jar app.jar
üîπ How It Works

Divides heap into regions (instead of separate Young & Old Gen).
Performs concurrent marking to identify garbage-heavy regions.
Collects garbage from the most-filled regions first.
Avoids long Full GC pauses, making it ideal for low-latency applications.
‚úÖ Used as the default GC from Java 9+.
‚úÖ Best choice for most applications.

üîπ Z Garbage Collector (ZGC) ‚Äì Best for Ultra-Low Latency
Designed for large heaps (>100GB).
Performs almost non-noticeable pause times (~2ms).
Uses region-based allocation with concurrent garbage collection.
üîπ Enable ZGC

bash
Copy
Edit
java -XX:+UseZGC -jar app.jar
üîπ How It Works

Allocates memory in regions (instead of fixed generations).
Uses colored pointers to track object reachability without stop-the-world events.
Only pauses application threads for <2ms, regardless of heap size.
‚úÖ Best for large-scale applications like financial trading, real-time systems.
‚úÖ Available from Java 11, fully stable in Java 17+.

üîπ Shenandoah GC (Best for Low-Pause, Real-Time Apps)
Focuses on low-pause time GC.
Uses concurrent compaction (so no stop-the-world for defragmentation).
Works well for heap sizes up to 32GB.
üîπ Enable Shenandoah GC

bash
Copy
Edit
java -XX:+UseShenandoahGC -jar app.jar
üîπ How It Works

Performs concurrent marking and compaction (so heap remains compact).
Avoids stop-the-world pauses except in rare cases.
Best for real-time applications needing consistent response times.
‚úÖ Best for UI applications, gaming, and JVM-based real-time systems.
‚úÖ Fully supported in Java 17+.

3. GC Performance Comparison
GC Type	Latency	Throughput	Heap Size Support	Use Case
Serial GC	High	Low	Small (<1GB)	Simple desktop apps
Parallel GC	Medium	High	Medium (1GB-10GB)	Batch processing
G1 GC	Low	High	Medium to Large (2GB-50GB)	General-purpose
ZGC	Ultra-low	Medium	Huge (50GB+)	Low-latency applications
Shenandoah GC	Ultra-low	High	Medium to Large (1GB-32GB)	Real-time, UI apps
4. How to Monitor GC Performance
Use JVisualVM or JConsole to monitor GC behavior:

bash
Copy
Edit
jvisualvm
Or analyze GC logs:

bash
Copy
Edit
java -Xlog:gc*:file=gc.log:time,uptime,level,tags -jar app.jar
5. Conclusion
For small apps, use Serial GC.
For high throughput, use Parallel GC.
For balanced performance, use G1 GC (default in Java 9+).
For ultra-low latency, use ZGC or Shenandoah GC.
