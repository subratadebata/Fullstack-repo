what is closures?

In JavaScript, a closure is a function that can access variables from its outer function, even after the outer function has finished executing. Closures are created when a function is defined inside another function. 
Lexical scope ?

Lexical scope in JavaScript is a programming concept that determines the scope of a variable based on where it's declared in the code. It's also known as static scoping. 

Event Loop and Asynchronous JavaScript
JavaScript uses an event loop to handle asynchronous operations. The call stack, callback queue, and microtask queue work together to execute synchronous and asynchronous code.

Execution Process:
Synchronous code executes first (Call Stack).
Promises and async/await go into the Microtask Queue (higher priority than Callback Queue).
Callbacks from events, timers, or async operations go into the Callback Queue.
Hoisting
Hoisting is JavaScript‚Äôs behavior of moving variable and function declarations to the top of their scope before execution.
Scope and Lexical Scope
Scope determines where a variable can be accessed.
Lexical Scope refers to how nested functions inherit variables from their parent functions.
this Keyword
The this keyword refers to the object that is executing the function.

Rules for this:
Global Scope (Non-strict Mode): this refers to window in browsers.
Inside an Object Method: this refers to the object.
Arrow Functions: this is lexically bound (does not get its own this).
Inside a Constructor Function: this refers to the new instance.
Callbacks, Promises, and Async/Await
Callbacks: Functions passed as arguments to be executed later.
Promises: Objects that represent future values (Pending, Fulfilled, Rejected).
Async/Await: Modern syntax for handling Promises.
 Destructuring
A way to extract values from arrays or objects.
Debouncing and Throttling
Debouncing: Delays execution until after a pause.
Throttling: Limits execution at fixed intervals.
What is the Virtual DOM in React?
The Virtual DOM (VDOM) is a lightweight, in-memory representation of the real DOM used by React to optimize UI rendering and updates efficiently.

How the Virtual DOM Works?
React creates a Virtual DOM tree that mirrors the actual DOM.
When state changes, React creates a new Virtual DOM.
React compares the new Virtual DOM with the previous one using a process called Reconciliation.
React determines the minimal changes (diffing algorithm) and updates only the necessary parts in the real DOM.
The Real DOM is updated efficiently, improving performance.
1. Types of Garbage Collectors in Java
Java provides multiple garbage collectors, each optimized for different performance requirements.

Garbage Collector	Algorithm Type	Best For
Serial GC	Stop-the-world, Mark-Sweep-Compact	Single-threaded environments
Parallel GC (Throughput GC)	Multi-threaded, Mark-Sweep-Compact	High throughput, multi-core systems
CMS (Concurrent Mark-Sweep) GC	Concurrent, Mark-Sweep	Low-latency applications
G1 (Garbage First) GC	Region-based, Concurrent	Balanced performance for large heaps
ZGC	Region-based, Low-latency	Very low pause times for large heaps
Shenandoah GC	Region-based, Concurrent	Extremely low pause times, multi-threaded
2. Java Memory Structure for GC
Java Heap Memory is divided into different regions:

Young Generation (Eden + Survivor Spaces)
Newly created objects.
Minor GC collects short-lived objects.
Old Generation (Tenured)
Long-lived objects that survive multiple GCs.
Major GC (Full GC) occurs here.
Metaspace
Stores class metadata (replaces PermGen in Java 8+).
3. Garbage Collection Algorithms
1Ô∏è‚É£ Serial Garbage Collector
Uses a single thread for GC.
Stop-the-world event pauses all application threads.
Suitable for small Java applications with a single-core CPU.
JVM Option: -XX:+UseSerialGC
üîπ Algorithm:

Mark ‚Äì Identifies live objects.
Sweep ‚Äì Removes dead objects.
Compact ‚Äì Defragments memory to reduce fragmentation.
2Ô∏è‚É£ Parallel Garbage Collector (Throughput GC)
Uses multiple threads for GC.
Still causes stop-the-world pauses.
Suitable for applications with high CPU power and large heaps.
JVM Option: -XX:+UseParallelGC
üîπ Algorithm:

Parallel Minor GC for Young Generation.
Parallel Major GC (Full GC) for Old Generation.
3Ô∏è‚É£ CMS (Concurrent Mark-Sweep) Garbage Collector (Deprecated in Java 14)
Reduces pause times by running concurrent threads for GC.
Best for low-latency applications.
JVM Option: -XX:+UseConcMarkSweepGC
üîπ Algorithm Steps:

Initial Mark ‚Äì Stops the application briefly to mark live objects.
Concurrent Mark ‚Äì Runs concurrently with application.
Concurrent Sweep ‚Äì Frees unused objects.
Final Remark ‚Äì Stops application briefly to finalize GC.
‚ùó Downsides:

Can cause fragmentation.
More CPU-intensive.
4Ô∏è‚É£ G1 (Garbage First) Garbage Collector (Default in Java 9+)
Region-based collector (instead of generational model).
Prioritizes regions with the most garbage.
JVM Option: -XX:+UseG1GC
üîπ Algorithm Steps:

Initial Mark ‚Äì Quick scan of heap.
Concurrent Marking ‚Äì Runs in the background.
Evacuation Pause ‚Äì Moves objects to compact memory.
Cleanup ‚Äì Removes unused regions.
‚úÖ Advantages:

Balanced performance.
Low pause times.
5Ô∏è‚É£ ZGC (Low-Latency GC)
Ultra-low pause times (<10ms), even with large heaps (up to 16TB).
JVM Option: -XX:+UseZGC
üîπ Key Features:

Fully concurrent ‚Äì GC runs alongside application.
Does not stop application threads.
6Ô∏è‚É£ Shenandoah GC
Similar to ZGC, with even shorter pause times.
JVM Option: -XX:+UseShenandoahGC
üîπ Key Features:

Concurrent Compaction ‚Äì Avoids full GC pauses.
Suitable for high-throughput, low-latency applications.
4. Choosing the Right Garbage Collector
Application Type	Best GC Choice
Small applications, single-threaded	Serial GC
Large-scale, CPU-intensive	Parallel GC
Low-latency apps	CMS (deprecated) / G1 GC
Ultra-low latency, large heap	ZGC / Shenandoah
5. How to Set GC in JVM
You can specify the garbage collector in your JVM options:

bash
Copy
Edit
java -XX:+UseG1GC -jar MyApp.jar  # Use G1 GC
java -XX:+UseParallelGC -jar MyApp.jar  # Use Parallel GC
java -XX:+UseZGC -jar MyApp.jar  # Use ZGC
Conclusion
Garbage Collection improves memory management in Java.
Different GC algorithms cater to different application needs.
G1 GC is the default in Java 9+, but ZGC and Shenandoah offer better performance for low-latency applications.
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           JVM Memory         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ    Method Area (Metaspace)   ‚îÇ  <-- Class Metadata, Static Variables
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ           Heap               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ  Young   ‚îÇ    Old       ‚îÇ ‚îÇ
‚îÇ  ‚îÇ(Eden, S0, S1) | Tenured ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ      Stack (Each Thread)     ‚îÇ  <-- Method Call Stack, Local Variables
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Native Method Stack (JNI)   ‚îÇ  <-- Calls Native C/C++ Methods
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ      Program Counter (PC)    ‚îÇ  <-- Current Execution Line
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

1. Types of Garbage Collectors in Java
Java provides multiple garbage collection algorithms, each with trade-offs in throughput, latency, and pause times.

Garbage Collector	Best For	GC Type	JVM Option
Serial GC	Small apps, single-threaded environments	Stop-the-world, single-threaded	-XX:+UseSerialGC
Parallel GC (Throughput GC)	High throughput, multi-threaded apps	Stop-the-world, multi-threaded	-XX:+UseParallelGC
G1 GC (Garbage First)	Low-latency, balanced apps	Region-based, concurrent	-XX:+UseG1GC
ZGC (Z Garbage Collector)	Ultra-low-latency, large heaps	Region-based, concurrent	-XX:+UseZGC
Shenandoah GC	Low-pause, real-time systems	Region-based, concurrent	-XX:+UseShenandoahGC
2. How Different Java GC Algorithms Work
üîπ Serial GC (Best for Small Applications)
Uses a single thread for garbage collection.
Performs stop-the-world (STW) pauses.
Suitable for small heap sizes (<1GB).
üîπ Enable Serial GC

bash
Copy
Edit
java -XX:+UseSerialGC -jar app.jar
üîπ How It Works

Stops all application threads during GC.
Runs Minor GC (Young Gen) and Major GC (Old Gen) sequentially.
Causes long pause times, so not suitable for large applications.
üîπ Parallel GC (Best for High Throughput)
Uses multiple threads to perform GC.
Focuses on throughput (faster execution, longer pauses).
Still performs stop-the-world but faster than Serial GC.
üîπ Enable Parallel GC

bash
Copy
Edit
java -XX:+UseParallelGC -jar app.jar
üîπ How It Works

Uses multiple threads to clean Young Gen.
Uses multiple threads for Full GC but still pauses the application.
Best for batch processing systems where pauses don‚Äôt matter.
üîπ G1 Garbage Collector (Best for Balanced Performance)
Divides heap into regions (Eden, Survivor, Old) instead of fixed generations.
Performs concurrent garbage collection, reducing pause times.
Prioritizes collecting regions with most garbage first.
üîπ Enable G1 GC

bash
Copy
Edit
java -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -jar app.jar
üîπ How It Works

Divides heap into regions (instead of separate Young & Old Gen).
Performs concurrent marking to identify garbage-heavy regions.
Collects garbage from the most-filled regions first.
Avoids long Full GC pauses, making it ideal for low-latency applications.
‚úÖ Used as the default GC from Java 9+.
‚úÖ Best choice for most applications.

üîπ Z Garbage Collector (ZGC) ‚Äì Best for Ultra-Low Latency
Designed for large heaps (>100GB).
Performs almost non-noticeable pause times (~2ms).
Uses region-based allocation with concurrent garbage collection.
üîπ Enable ZGC

bash
Copy
Edit
java -XX:+UseZGC -jar app.jar
üîπ How It Works

Allocates memory in regions (instead of fixed generations).
Uses colored pointers to track object reachability without stop-the-world events.
Only pauses application threads for <2ms, regardless of heap size.
‚úÖ Best for large-scale applications like financial trading, real-time systems.
‚úÖ Available from Java 11, fully stable in Java 17+.

üîπ Shenandoah GC (Best for Low-Pause, Real-Time Apps)
Focuses on low-pause time GC.
Uses concurrent compaction (so no stop-the-world for defragmentation).
Works well for heap sizes up to 32GB.
üîπ Enable Shenandoah GC

bash
Copy
Edit
java -XX:+UseShenandoahGC -jar app.jar
üîπ How It Works

Performs concurrent marking and compaction (so heap remains compact).
Avoids stop-the-world pauses except in rare cases.
Best for real-time applications needing consistent response times.
‚úÖ Best for UI applications, gaming, and JVM-based real-time systems.
‚úÖ Fully supported in Java 17+.

3. GC Performance Comparison
GC Type	Latency	Throughput	Heap Size Support	Use Case
Serial GC	High	Low	Small (<1GB)	Simple desktop apps
Parallel GC	Medium	High	Medium (1GB-10GB)	Batch processing
G1 GC	Low	High	Medium to Large (2GB-50GB)	General-purpose
ZGC	Ultra-low	Medium	Huge (50GB+)	Low-latency applications
Shenandoah GC	Ultra-low	High	Medium to Large (1GB-32GB)	Real-time, UI apps
4. How to Monitor GC Performance
Use JVisualVM or JConsole to monitor GC behavior:

bash
Copy
Edit
jvisualvm
Or analyze GC logs:

bash
Copy
Edit
java -Xlog:gc*:file=gc.log:time,uptime,level,tags -jar app.jar
5. Conclusion
For small apps, use Serial GC.
For high throughput, use Parallel GC.
For balanced performance, use G1 GC (default in Java 9+).
For ultra-low latency, use ZGC or Shenandoah GC.

The JavaScript Tree:

|
|‚îÄ‚îÄ Variables
| ‚îú‚îÄ‚îÄ var
| ‚îú‚îÄ‚îÄ let
| ‚îî‚îÄ‚îÄ const
|
|‚îÄ‚îÄ Data Types
| ‚îú‚îÄ‚îÄ String
| ‚îú‚îÄ‚îÄ Number
| ‚îú‚îÄ‚îÄ Boolean
| ‚îú‚îÄ‚îÄ Object
| ‚îú‚îÄ‚îÄ Array
| ‚îú‚îÄ‚îÄ Null
| ‚îî‚îÄ‚îÄ Undefined
|
|‚îÄ‚îÄ Operators
| ‚îú‚îÄ‚îÄ Arithmetic
| ‚îú‚îÄ‚îÄ Assignment
| ‚îú‚îÄ‚îÄ Comparison
| ‚îú‚îÄ‚îÄ Logical
| ‚îú‚îÄ‚îÄ Unary
| ‚îî‚îÄ‚îÄ Ternary (Conditional)
|
|‚îÄ‚îÄ Control Flow
| ‚îú‚îÄ‚îÄ if statement
| ‚îú‚îÄ‚îÄ else statement
| ‚îú‚îÄ‚îÄ else if statement
| ‚îú‚îÄ‚îÄ switch statement
| ‚îú‚îÄ‚îÄ for loop
| ‚îú‚îÄ‚îÄ while loop
| ‚îî‚îÄ‚îÄ do-while loop
|
|‚îÄ‚îÄ Functions
| ‚îú‚îÄ‚îÄ Function declaration
| ‚îú‚îÄ‚îÄ Function expression
| ‚îú‚îÄ‚îÄ Arrow function
| ‚îî‚îÄ‚îÄ IIFE (Immediately Invoked Function Expression)
|
|‚îÄ‚îÄ Scope
| ‚îú‚îÄ‚îÄ Global scope
| ‚îú‚îÄ‚îÄ Local scope
| ‚îú‚îÄ‚îÄ Block scope
| ‚îî‚îÄ‚îÄ Lexical scope
|
|‚îÄ‚îÄ Arrays
| ‚îú‚îÄ‚îÄ Array methods
| | ‚îú‚îÄ‚îÄ push()
| | ‚îú‚îÄ‚îÄ pop()
| | ‚îú‚îÄ‚îÄ shift()
| | ‚îú‚îÄ‚îÄ unshift()
| | ‚îú‚îÄ‚îÄ splice()
| | ‚îú‚îÄ‚îÄ slice()
| | ‚îî‚îÄ‚îÄ concat()
| ‚îî‚îÄ‚îÄ Array iteration
| ‚îú‚îÄ‚îÄ forEach()
| ‚îú‚îÄ‚îÄ map()
| ‚îú‚îÄ‚îÄ filter()
| ‚îî‚îÄ‚îÄ reduce()
|
|‚îÄ‚îÄ Objects
| ‚îú‚îÄ‚îÄ Object properties
| | ‚îú‚îÄ‚îÄ Dot notation
| | ‚îî‚îÄ‚îÄ Bracket notation
| ‚îú‚îÄ‚îÄ Object methods
| | ‚îú‚îÄ‚îÄ Object.keys()
| | ‚îú‚îÄ‚îÄ Object.values()
| | ‚îî‚îÄ‚îÄ Object.entries()
| ‚îî‚îÄ‚îÄ Object destructuring
|
|‚îÄ‚îÄ Promises
| ‚îú‚îÄ‚îÄ Promise states
| | ‚îú‚îÄ‚îÄ Pending
| | ‚îú‚îÄ‚îÄ Fulfilled
| | ‚îî‚îÄ‚îÄ Rejected
| ‚îú‚îÄ‚îÄ Promise methods
| | ‚îú‚îÄ‚îÄ then()
| | ‚îú‚îÄ‚îÄ catch()
| | ‚îî‚îÄ‚îÄ finally()
| ‚îî‚îÄ‚îÄ Promise.all()
|
|‚îÄ‚îÄ Asynchronous JavaScript
| ‚îú‚îÄ‚îÄ Callbacks
| ‚îú‚îÄ‚îÄ Promises
| ‚îî‚îÄ‚îÄ Async/Await
|
|‚îÄ‚îÄ Error Handling
| ‚îú‚îÄ‚îÄ try...catch statement
| ‚îî‚îÄ‚îÄ throw statement
|
|‚îÄ‚îÄ JSON (JavaScript Object Notation)
|
|‚îÄ‚îÄ Modules
| ‚îú‚îÄ‚îÄ import
| ‚îî‚îÄ‚îÄ export
|
|‚îÄ‚îÄ DOM Manipulation
| ‚îú‚îÄ‚îÄ Selecting elements
| ‚îú‚îÄ‚îÄ Modifying elements
| ‚îî‚îÄ‚îÄ Creating elements
|
|‚îÄ‚îÄ Events
| ‚îú‚îÄ‚îÄ Event listeners
| ‚îú‚îÄ‚îÄ Event propagation
| ‚îî‚îÄ‚îÄ Event delegation
|
|‚îÄ‚îÄ AJAX (Asynchronous JavaScript and XML)
|
|‚îÄ‚îÄ Fetch API
|
|‚îÄ‚îÄ ES6+ Features
| ‚îú‚îÄ‚îÄ Template literals
| ‚îú‚îÄ‚îÄ Destructuring assignment
| ‚îú‚îÄ‚îÄ Spread/rest operator
| ‚îú‚îÄ‚îÄ Arrow functions
| ‚îú‚îÄ‚îÄ Classes
| ‚îú‚îÄ‚îÄ let and const
| ‚îú‚îÄ‚îÄ Default parameters
| ‚îú‚îÄ‚îÄ Modules
| ‚îî‚îÄ‚îÄ Promises
|
|‚îÄ‚îÄ Web APIs
| ‚îú‚îÄ‚îÄ Local Storage
| ‚îú‚îÄ‚îÄ Session Storage
| ‚îî‚îÄ‚îÄ Web Storage API
|
|‚îÄ‚îÄ Libraries and Frameworks
| ‚îú‚îÄ‚îÄ React
| ‚îú‚îÄ‚îÄ Angular
| ‚îî‚îÄ‚îÄ Vue.js
|
|‚îÄ‚îÄ Debugging
| ‚îú‚îÄ‚îÄ Console.log()
| ‚îú‚îÄ‚îÄ Breakpoints
| ‚îî‚îÄ‚îÄ DevTools
|
|‚îÄ‚îÄ Others
| ‚îú‚îÄ‚îÄ Closures
| ‚îú‚îÄ‚îÄ Callbacks
| ‚îú‚îÄ‚îÄ Prototypes
| ‚îú‚îÄ‚îÄ this keyword
| ‚îú‚îÄ‚îÄ Hoisting
| ‚îî‚îÄ‚îÄ Strict mode

Asynchronous JavaScript
1. What is the Event Loop in JavaScript, and how does it work?
The Event Loop is a mechanism in JavaScript that handles asynchronous operations. It continuously checks the Call Stack and Task Queue. If the call stack is empty, it picks the next task from the queue and pushes it onto the stack for execution.

2. What are Microtasks and Macrotasks, and how are they scheduled in JavaScript?
Microtasks (Promise callbacks, process.nextTick) have higher priority and are executed immediately after the current operation completes, before the Event Loop moves to the next cycle.
Macrotasks (setTimeout, setImmediate, I/O operations) are scheduled after microtasks and executed in the next event loop iteration.
3. What is the difference between setTimeout, setImmediate, and process.nextTick?
setTimeout: Executes after a specified delay (minimum of 4ms if 0 is given).
setImmediate: Executes after the current event loop phase ends.
process.nextTick: Executes immediately after the current function completes, before I/O or timers.
4. How does JavaScript handle asynchronous operations?
JavaScript handles async operations using the Event Loop, which processes tasks from the Call Stack, Task Queue, and Microtask Queue.

5. What is a Promise, and how does it work under the hood?
A Promise represents an asynchronous operation with three states: pending, fulfilled, or rejected. Under the hood, it uses a microtask queue for .then() and .catch() callbacks, ensuring they execute before macrotasks.

6. What is the difference between Promises and async/await?
Promises use .then() and .catch() for chaining.
async/await is syntactic sugar over Promises, making code look synchronous while still being asynchronous.
7. How does JavaScript handle callback functions internally?
JavaScript stores callbacks in the Task Queue (macrotasks) or Microtask Queue and executes them when the event loop allows.

8. What is the difference between process.nextTick and setImmediate in Node.js?
process.nextTick(): Runs before the next event loop iteration.
setImmediate(): Runs in the check phase of the event loop, after I/O operations.
9. What is the Job Queue in JavaScript, and how does it prioritize tasks?
The Job Queue (Microtask Queue) has higher priority than the Task Queue (Macrotask Queue). Microtasks execute before macrotasks.

10. How does requestAnimationFrame work in JavaScript?
requestAnimationFrame(callback) schedules the callback to run before the next repaint (~16.67ms for 60fps), optimizing animations.

Modules, Concurrency, and Performance
11. What are JavaScript Modules, and how do they work?
JavaScript modules allow code organization using export and import statements. ES6 Modules are static and resolved at compile-time, while CommonJS modules are dynamic and loaded at runtime.

12. What is the difference between CommonJS and ES6 Modules?
CommonJS (require()): Used in Node.js, synchronous, executes immediately.
ES6 Modules (import/export): Asynchronous, supports tree shaking, works in both browsers and Node.js.
13. How does tree shaking work in JavaScript bundlers like Webpack?
Tree shaking eliminates unused code (dead code elimination) by analyzing module imports.

14. What are Web Workers, and how do they improve JavaScript performance?
Web Workers run scripts in background threads, preventing UI blocking.

15. What is the difference between synchronous and asynchronous JavaScript?
Synchronous: Blocks the execution of subsequent code until the current operation completes.
Asynchronous: Uses callbacks, promises, and async/await to prevent blocking.
16. How does JavaScript handle multi-threading and concurrency?
JavaScript is single-threaded but supports concurrency using Web Workers and async operations.

17. What is requestIdleCallback, and how does it optimize performance?
requestIdleCallback(callback) executes low-priority tasks when the browser is idle.

18. What is the difference between Debouncing and Throttling?
Debouncing: Delays function execution until a specified time after the last event.
Throttling: Ensures a function executes at most once in a given time frame.
19. What is the difference between imperative and declarative programming in JavaScript?
Imperative: Explicitly describes how to perform tasks (e.g., loops).
Declarative: Describes what should be done (e.g., map(), filter()).
20. How does JavaScript handle BigInt and floating-point precision?
BigInt (123n) supports arbitrarily large integers.
Floating-point numbers use IEEE 754 format, causing precision errors (e.g., 0.1 + 0.2 !== 0.3).
