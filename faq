What is Var,let and const ?
 What?
 var ‚Üí Function-scoped, hoisted, can be re-declared and reassigned.
 let ‚Üí Block-scoped, hoisted but not initialized, can be reassigned but not re-declared.
 const ‚Üí Block-scoped, must be initialized, cannot be reassigned or re-declared.
let
let age = 25;
age = 26;  
console.log(age); 
const
const name = "Alice";
name = "Bob";  
var
console.log(a);
var a = 10;

console.log(b); 
let b = 20;
üîπ Best Practice
‚úÖ Use const by default.
‚úÖ Use let when reassignment is needed.
‚úÖ Avoid var due to scoping issues.
What is ingress.yml?

An ingress.yml file defines Ingress resources in Kubernetes, which control how external traffic reaches services inside a Kubernetes cluster.
It acts as a smart router, directing HTTP/HTTPS traffic based on rules.
Use ingress.yml when:
‚úî You need to expose multiple services under a single domain.
‚úî You want path-based or host-based routing (e.g., /api ‚Üí Service A, /app ‚Üí Service B).
‚úî You require TLS/SSL termination for secure connections.
‚úî You want to avoid exposing multiple LoadBalancers (cost-efficient).
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - host: myapp.example.com  # Domain name
    http:
      paths:
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 80
      - path: /web
        pathType: Prefix
        backend:
          service:
            name: web-service
            port:
              number: 80


hread-Safety of ConcurrentHashMap, Hashtable, and SynchronizedMap
All three are thread-safe, but they achieve it in different ways:

Feature	ConcurrentHashMap üü¢	Hashtable üîµ	Collections.synchronizedMap() üü°
Thread-Safe?	‚úÖ Yes	‚úÖ Yes	‚úÖ Yes
Locking Mechanism	Segmented Locking (locks only parts of the map)	Synchronized Methods (locks the entire table)	Synchronized Wrapper (locks the entire map)
Performance	üî• High (better concurrency)	üê¢ Slow (locks everything)	üê¢ Slow (locks everything)
Concurrent Reads?	‚úÖ Yes (reads do not block)	‚ùå No (reads are synchronized)	‚ùå No (reads are synchronized)
Concurrent Writes?	‚úÖ Yes (writes only lock specific buckets)	‚ùå No (locks entire table)	‚ùå No (locks entire map)
Iteration Behavior	‚úÖ Fail-Fast (ConcurrentModificationException)	‚ùå Uses Enumeration (Safe)	‚úÖ Fail-Fast (ConcurrentModificationException)
Which One is Best for Thread Safety?
‚úî Use ConcurrentHashMap if you need high performance in a multi-threaded environment.
‚úî Use Hashtable only for legacy code (it's fully synchronized but slow).
‚úî Use Collections.synchronizedMap() if you need a quick thread-safe wrapper for a HashMap but don‚Äôt need high concurrency.

Combining Results from Multiple Sources Using CompletableFuture in Java
CompletableFuture is a powerful tool for handling asynchronous computations in Java. You can combine results from multiple sources using:

thenCombine() ‚Üí Combine results of two futures.
thenCompose() ‚Üí Chain dependent tasks.
allOf() ‚Üí Combine multiple futures and wait for all.
anyOf() ‚Üí Return the result of the fastest future.
1Ô∏è‚É£ Using thenCombine() ‚Äì Combining Two Results
If you have two independent computations and want to combine their results, use thenCombine().


import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class CombineFuturesExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> 10);
        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> 20);

        CompletableFuture<Integer> result = future1.thenCombine(future2, (a, b) -> a + b);

        System.out.println("Combined Result: " + result.get()); // Output: 30
    }
}
‚úÖ Use Case: When two independent tasks finish and you need their combined result.
2Ô∏è‚É£ Using thenCompose() ‚Äì Dependent Tasks
If one computation depends on the result of another, use thenCompose().
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class ThenComposeExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "Hello")
                .thenCompose(s -> CompletableFuture.supplyAsync(() -> s + " World"));

        System.out.println(future.get()); // Output: Hello World
    }
}

Use Case: When a second task depends on the result of the first.

3Ô∏è‚É£ Using allOf() ‚Äì Combining Multiple Futures
If you have multiple independent tasks and want to wait for all of them to complete:
import java.util.concurrent.*;

public class AllOfExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> 10);
        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> 20);
        CompletableFuture<Integer> future3 = CompletableFuture.supplyAsync(() -> 30);

        CompletableFuture<Void> allFutures = CompletableFuture.allOf(future1, future2, future3);

        allFutures.get(); // Wait for all to complete

        int sum = future1.get() + future2.get() + future3.get();
        System.out.println("Total Sum: " + sum); // Output: 60
    }
}
Use Case: When you want to wait for all tasks but don‚Äôt need a combined result.
4Ô∏è‚É£ Using anyOf() ‚Äì Return the First Completed Result
If you want to return the first completed result (fastest future):

Method	Purpose
thenCombine()	Combine results of two independent futures.
thenCompose()	Chain dependent computations.
allOf()	Wait for all tasks but doesn‚Äôt return combined results.
anyOf()	Return the first completed task‚Äôs result.
How do you implement timeout using CompletableFuture?
1Ô∏è‚É£ Using orTimeout() (Java 9+)
The simplest approach, available in Java 9+.
Automatically fails the future with a TimeoutException if it exceeds the given time.
import java.util.concurrent.*;

public class CompletableFutureTimeoutExample {
    public static void main(String[] args) {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            sleep(3); // Simulate delay
            return "Task Completed";
        }).orTimeout(2, TimeUnit.SECONDS); // Timeout after 2 sec

        try {
            System.out.println(future.get()); // Throws TimeoutException
        } catch (Exception e) {
            System.out.println("Exception: " + e); // Output: java.util.concurrent.TimeoutException
        }
    }

    private static void sleep(int sec) {
        try { Thread.sleep(sec * 1000); } catch (InterruptedException e) { e.printStackTrace(); }
    }
}
 Best for: Simple timeout handling when using Java 9+.
2Ô∏è‚É£ Using completeOnTimeout() (Java 9+)
Instead of throwing an exception, it returns a default value when the timeout occurs.

import java.util.concurrent.*;

public class CompleteOnTimeoutExample {
    public static void main(String[] args) {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            sleep(3); // Simulate delay
            return "Task Completed";
        }).completeOnTimeout("Default Value", 2, TimeUnit.SECONDS); // Return default after 2 sec

        try {
            System.out.println(future.get()); // Output: Default Value
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void sleep(int sec) {
        try { Thread.sleep(sec * 1000); } catch (InterruptedException e) { e.printStackTrace(); }
    }
}
 Best for: Returning a default value instead of throwing an exception.
import java.util.concurrent.*;

public class TimeoutWithExecutor {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newScheduledThreadPool(1);

        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            sleep(3); // Simulate long task
            return "Task Completed";
        });

        CompletableFuture<String> timeoutFuture = new CompletableFuture<>();
        executor.schedule(() -> timeoutFuture.completeExceptionally(new TimeoutException()), 2, TimeUnit.SECONDS);

        CompletableFuture<String> result = future.applyToEither(timeoutFuture, res -> res);

        try {
            System.out.println(result.get()); // Throws TimeoutException
        } catch (Exception e) {
            System.out.println("Exception: " + e);
        } finally {
            executor.shutdown();
        }
    }

    private static void sleep(int sec) {
        try { Thread.sleep(sec * 1000); } catch (InterruptedException e) { e.printStackTrace(); }
    }
}

 Best for: Java 8 compatibility (alternative to orTimeout()).

Method	Available Since	Behavior
orTimeout()	Java 9+	Throws TimeoutException if it exceeds the time limit.
completeOnTimeout()	Java 9+	Returns a default value instead of throwing an exception.
applyToEither() + ScheduledExecutorService	Java 8	Uses an external scheduler to manually handle timeouts.
