What is Var,let and const ?
 What?
 var â†’ Function-scoped, hoisted, can be re-declared and reassigned.
 let â†’ Block-scoped, hoisted but not initialized, can be reassigned but not re-declared.
 const â†’ Block-scoped, must be initialized, cannot be reassigned or re-declared.
let
let age = 25;
age = 26;  
console.log(age); 
const
const name = "Alice";
name = "Bob";  
var
console.log(a);
var a = 10;

console.log(b); 
let b = 20;
ğŸ”¹ Best Practice
âœ… Use const by default.
âœ… Use let when reassignment is needed.
âœ… Avoid var due to scoping issues.
What is ingress.yml?

An ingress.yml file defines Ingress resources in Kubernetes, which control how external traffic reaches services inside a Kubernetes cluster.
It acts as a smart router, directing HTTP/HTTPS traffic based on rules.
Use ingress.yml when:
âœ” You need to expose multiple services under a single domain.
âœ” You want path-based or host-based routing (e.g., /api â†’ Service A, /app â†’ Service B).
âœ” You require TLS/SSL termination for secure connections.
âœ” You want to avoid exposing multiple LoadBalancers (cost-efficient).
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - host: myapp.example.com  # Domain name
    http:
      paths:
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 80
      - path: /web
        pathType: Prefix
        backend:
          service:
            name: web-service
            port:
              number: 80


hread-Safety of ConcurrentHashMap, Hashtable, and SynchronizedMap
All three are thread-safe, but they achieve it in different ways:

Feature	ConcurrentHashMap ğŸŸ¢	Hashtable ğŸ”µ	Collections.synchronizedMap() ğŸŸ¡
Thread-Safe?	âœ… Yes	âœ… Yes	âœ… Yes
Locking Mechanism	Segmented Locking (locks only parts of the map)	Synchronized Methods (locks the entire table)	Synchronized Wrapper (locks the entire map)
Performance	ğŸ”¥ High (better concurrency)	ğŸ¢ Slow (locks everything)	ğŸ¢ Slow (locks everything)
Concurrent Reads?	âœ… Yes (reads do not block)	âŒ No (reads are synchronized)	âŒ No (reads are synchronized)
Concurrent Writes?	âœ… Yes (writes only lock specific buckets)	âŒ No (locks entire table)	âŒ No (locks entire map)
Iteration Behavior	âœ… Fail-Fast (ConcurrentModificationException)	âŒ Uses Enumeration (Safe)	âœ… Fail-Fast (ConcurrentModificationException)
Which One is Best for Thread Safety?
âœ” Use ConcurrentHashMap if you need high performance in a multi-threaded environment.
âœ” Use Hashtable only for legacy code (it's fully synchronized but slow).
âœ” Use Collections.synchronizedMap() if you need a quick thread-safe wrapper for a HashMap but donâ€™t need high concurrency.

Combining Results from Multiple Sources Using CompletableFuture in Java
CompletableFuture is a powerful tool for handling asynchronous computations in Java. You can combine results from multiple sources using:

thenCombine() â†’ Combine results of two futures.
thenCompose() â†’ Chain dependent tasks.
allOf() â†’ Combine multiple futures and wait for all.
anyOf() â†’ Return the result of the fastest future.
1ï¸âƒ£ Using thenCombine() â€“ Combining Two Results
If you have two independent computations and want to combine their results, use thenCombine().


import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class CombineFuturesExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> 10);
        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> 20);

        CompletableFuture<Integer> result = future1.thenCombine(future2, (a, b) -> a + b);

        System.out.println("Combined Result: " + result.get()); // Output: 30
    }
}
âœ… Use Case: When two independent tasks finish and you need their combined result.
2ï¸âƒ£ Using thenCompose() â€“ Dependent Tasks
If one computation depends on the result of another, use thenCompose().
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class ThenComposeExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "Hello")
                .thenCompose(s -> CompletableFuture.supplyAsync(() -> s + " World"));

        System.out.println(future.get()); // Output: Hello World
    }
}

Use Case: When a second task depends on the result of the first.

3ï¸âƒ£ Using allOf() â€“ Combining Multiple Futures
If you have multiple independent tasks and want to wait for all of them to complete:
import java.util.concurrent.*;

public class AllOfExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> 10);
        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> 20);
        CompletableFuture<Integer> future3 = CompletableFuture.supplyAsync(() -> 30);

        CompletableFuture<Void> allFutures = CompletableFuture.allOf(future1, future2, future3);

        allFutures.get(); // Wait for all to complete

        int sum = future1.get() + future2.get() + future3.get();
        System.out.println("Total Sum: " + sum); // Output: 60
    }
}
Use Case: When you want to wait for all tasks but donâ€™t need a combined result.
4ï¸âƒ£ Using anyOf() â€“ Return the First Completed Result
If you want to return the first completed result (fastest future):

Method	Purpose
thenCombine()	Combine results of two independent futures.
thenCompose()	Chain dependent computations.
allOf()	Wait for all tasks but doesnâ€™t return combined results.
anyOf()	Return the first completed taskâ€™s result.

